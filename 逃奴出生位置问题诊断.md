# 逃奴出生位置设置问题诊断

## 问题描述
选择逃奴出身后，选择"沙漠深处"或"逃亡帝国"时，出生位置没有正确设置。

## 代码实现位置
- **文件**: `SubModule/PresetOriginSystem.cs`
- **方法**: `ApplySlaveEscapeNode5()` 和 `SetSlaveEscapeStartingLocation()`
- **调用链**: `ApplyPresetOrigin()` → `ApplySlaveEscapeOrigin()` → `ApplySlaveEscapeNode5()` → `SetSlaveEscapeStartingLocation()`

## 可能的问题原因

### 1. 时机问题 ⚠️ **最可能**
**问题**: `ApplyPresetOrigin()` 可能在角色创建阶段被调用，此时：
- `MobileParty.MainParty` 可能还未完全初始化
- 队伍位置可能在设置后被游戏引擎重置
- 地图可能还未加载完成

**证据**:
- 代码中使用了 `MobileParty.MainParty`，但在角色创建阶段，主队伍可能还不存在或位置会被重置

### 2. Position2D 属性只读问题
**问题**: `MobileParty.Position2D` 可能是只读属性，无法直接设置

**当前代码尝试**:
```csharp
var positionProperty = typeof(MobileParty).GetProperty("Position2D", BindingFlags.Public | BindingFlags.Instance);
if (positionProperty != null && positionProperty.CanWrite)
{
    positionProperty.SetValue(party, position);
}
```

**可能失败原因**:
- 属性可能是只读的（`CanWrite` 返回 `false`）
- 即使通过反射设置了，游戏引擎可能在下一帧重置

### 3. Settlement.Position 类型不匹配
**问题**: `Settlement.Position` 返回的是 `Vec3`（3D坐标），而 `MobileParty.Position2D` 需要 `Vec2`（2D坐标）

**当前代码**:
```csharp
var position = targetSettlement.Position; // 这是 Vec3
// ...
positionProperty.SetValue(party, position); // 但 Position2D 需要 Vec2
```

**修复建议**: 需要转换为 Vec2:
```csharp
var position3D = targetSettlement.Position;
var position = new Vec2(position3D.x, position3D.y);
```

### 4. 调用时机不对
**问题**: `ApplyPresetOrigin()` 可能在游戏开始后才被调用，此时位置已经固定

**需要检查**:
- `OriginSystemCampaignBehavior` 中何时调用 `ApplyPresetOrigin()`
- 是否在 `OnGameStart()` 或 `OnNewGameCreated()` 中调用
- 是否在角色创建完成后才调用

## 解决方案

### 方案1: 延迟设置位置（推荐）
在游戏真正开始后（`OnGameStart` 或第一次进入地图时）设置位置：

```csharp
// 在 OriginSystemCampaignBehavior 中
public override void OnGameStart(Game game, IGameStarter gameStarter)
{
    if (OriginSystemHelper.SelectedPresetOriginId == "slave_escape")
    {
        var direction = OriginSystemHelper.SelectedPresetOriginNodes.GetValueOrDefault("khz_node_ex_slave_direction");
        if (direction == "desert" || direction == "empire")
        {
            // 延迟一帧设置位置，确保地图已加载
            Campaign.Current?.GetCampaignBehavior<CampaignBehaviorBase>()?.OnDailyTick();
            // 或者使用定时器
        }
    }
}
```

### 方案2: 使用 TeleportPartyAction
查找 Bannerlord 的 `TeleportPartyAction` 或类似的动作类：

```csharp
// 尝试使用游戏内置的传送动作
var teleportType = Type.GetType("TaleWorlds.CampaignSystem.Actions.TeleportPartyAction, TaleWorlds.CampaignSystem");
if (teleportType != null)
{
    var applyMethod = teleportType.GetMethod("Apply", BindingFlags.Public | BindingFlags.Static);
    if (applyMethod != null)
    {
        // 需要确认参数类型
        applyMethod.Invoke(null, new object[] { party, position, settlement });
    }
}
```

### 方案3: 使用 CampaignBehavior 延迟执行
在 `OriginSystemCampaignBehavior` 中添加逻辑，在游戏开始后的第一帧设置位置：

```csharp
private bool _hasSetSlaveEscapePosition = false;

public override void OnDailyTick()
{
    if (!_hasSetSlaveEscapePosition && Hero.MainHero != null && MobileParty.MainParty != null)
    {
        var originId = OriginSystemHelper.SelectedPresetOriginId;
        if (originId == "slave_escape")
        {
            var direction = OriginSystemHelper.SelectedPresetOriginNodes.GetValueOrDefault("khz_node_ex_slave_direction");
            if (direction == "desert" || direction == "empire")
            {
                SetSlaveEscapeStartingLocation(MobileParty.MainParty, direction);
                _hasSetSlaveEscapePosition = true;
            }
        }
    }
}
```

### 方案4: 修复类型转换问题
确保 `Vec3` 正确转换为 `Vec2`：

```csharp
var position3D = targetSettlement.Position;
var position = new Vec2(position3D.x, position3D.y);
```

## 调试建议

### 1. 添加详细日志
在 `SetSlaveEscapeStartingLocation` 中添加更多日志：

```csharp
OriginLog.Info($"[SlaveEscape] 开始设置出生位置: direction={direction}");
OriginLog.Info($"[SlaveEscape] MainParty 状态: {(party == null ? "NULL" : "存在")}");
OriginLog.Info($"[SlaveEscape] Campaign.Current 状态: {(Campaign.Current == null ? "NULL" : "存在")}");
OriginLog.Info($"[SlaveEscape] Settlements 数量: {Campaign.Current?.Settlements?.Count() ?? 0}");
```

### 2. 检查调用时机
在 `ApplyPresetOrigin()` 和 `ApplySlaveEscapeOrigin()` 中添加日志：

```csharp
OriginLog.Info($"[SlaveEscape] ApplyPresetOrigin 被调用: originId={originId}");
OriginLog.Info($"[SlaveEscape] ApplySlaveEscapeOrigin 被调用");
OriginLog.Info($"[SlaveEscape] MainParty 位置: {MobileParty.MainParty?.Position2D}");
```

### 3. 验证位置设置是否成功
在设置位置后立即检查：

```csharp
positionProperty.SetValue(party, position);
var newPosition = party.Position2D;
OriginLog.Info($"[SlaveEscape] 位置设置后: {newPosition.X}, {newPosition.Y}");
```

## 下一步行动

1. ✅ **检查编译错误** - 确保所有 `CultureObject` 和 `Debug` 错误已修复
2. ⏳ **添加详细日志** - 在关键位置添加日志，确认代码执行路径
3. ⏳ **修复类型转换** - 确保 `Vec3` 正确转换为 `Vec2`
4. ⏳ **测试调用时机** - 确认 `ApplyPresetOrigin()` 在何时被调用
5. ⏳ **实现延迟设置** - 如果时机不对，使用 CampaignBehavior 延迟设置位置

## 已修复的问题

### ✅ 类型转换问题（已修复）
**问题**: `Settlement.Position` 返回 `CampaignVec2`，需要使用 `.X` 和 `.Y` 属性转换为 `Vec2`

**修复**:
```csharp
var settlementPos = targetSettlement.Position;
var position = new Vec2(settlementPos.X, settlementPos.Y);
```

## 已实现的修复

### ✅ 1. 延迟执行策略（已实现）
**问题**: 在角色创建阶段设置位置会被引擎后续初始化覆盖

**修复**:
- 在 `ApplySlaveEscapeNode5` 中不再立即设置位置，而是调用 `SaveSlaveEscapeStartingLocation` 保存期望位置
- 在 `OriginSystemHelper` 中添加 `PendingStartDirection` 和 `PendingStartSettlementId` 字段
- 在 `OriginSystemCampaignBehavior.OnTick` 中延迟1秒后执行 teleport，确保地图和队伍已完全初始化

### ✅ 2. 坐标源修复（已实现）
**问题**: 使用 `Settlement.Position`（CampaignVec2）可能不是最佳选择

**修复**:
- 优先尝试使用 `Settlement.GatePosition`（如果存在，通常是 Vec2，更适合 Party 位置）
- 如果 `GatePosition` 不可用，回退到使用 `Settlement.Position` 并转换为 `Vec2`
- 使用反射安全地访问这些属性

### ✅ 3. Position2D 访问修复（已实现）
**问题**: `MobileParty.Position2D` 可能无法直接访问（编译错误）

**修复**:
- 使用反射访问 `Position2D` 属性，避免编译错误
- 在 `ApplySlaveEscapeNode5`、`SetSlaveEscapeStartingLocation` 和 `VerifyNextTick` 中都使用反射

### ✅ 4. 三段式日志（已实现）
**修复**: 添加了完整的三段式日志系统

1. **`[SlaveEscape][Apply]`**: 在 `ApplySlaveEscapeNode5` 中记录调用时机和状态
   - 记录 `direction`、`campaign`、`mainHero`、`mainParty`、当前 `pos`

2. **`[SlaveEscape][Teleport]`**: 在 `SetSlaveEscapeStartingLocation` 中记录 teleport 过程
   - 记录 `when`（延迟执行）、`before`（teleport 前位置）、`targetSettlement`、`targetName`、`after`（teleport 后位置）、`success`

3. **`[SlaveEscape][VerifyNextTick]`**: 在下一帧验证位置是否被覆盖
   - 记录 `pos`，如果和 `after` 不同，说明被引擎覆盖

### ✅ 5. 多种 Teleport 方法尝试（已实现）
**修复**: 按优先级尝试多种方法设置位置

1. **TeleportPartyAction.Apply**（如果存在）
2. **反射设置 Position2D 属性**（如果可写）
3. **反射设置 _position2D 字段**（最后手段）

## 当前代码状态

- ✅ 代码已编译通过（0 errors, 0 warnings）
- ✅ 延迟执行策略已实现
- ✅ 坐标源修复（优先使用 GatePosition）
- ✅ Position2D 访问修复（使用反射）
- ✅ 三段式日志已完整实现
- ✅ 多种 teleport 方法已实现
- ⏳ **需要运行时验证**: 运行游戏测试，查看日志确认修复是否生效

## 预期日志输出示例

```
[SlaveEscape][Apply] direction=desert campaign=True mainHero=True mainParty=True pos=(100.00,200.00)
[SlaveEscape][Apply] 已保存期望出生位置: direction=desert settlementId=town_AN1 settlementName=Quyaz
[SlaveEscape][Teleport] when=延迟执行 before=(100.00,200.00) targetSettlement=town_AN1 targetName=Quyaz
[SlaveEscape][Teleport] 使用反射设置 Position2D 属性
[SlaveEscape][Teleport] after=(450.00,650.00) success=True
[SlaveEscape][VerifyNextTick] pos=(450.00,650.00)
```

如果 `VerifyNextTick` 的位置和 `after` 不同，说明位置被引擎覆盖，需要进一步延迟执行时机。

## 下一步调试步骤

1. **运行游戏并查看日志**:
   - 选择逃奴出身
   - 选择"沙漠深处"或"逃亡帝国"
   - 查看日志中的三段式输出
   - 确认位置设置是否成功

2. **如果位置设置失败**:
   - 检查日志中的错误信息
   - 确认哪种 teleport 方法成功（TeleportPartyAction / Position2D 属性 / _position2D 字段）
   - 如果所有方法都失败，需要查找其他 Bannerlord API

3. **如果位置设置成功但被重置**:
   - 查看 `VerifyNextTick` 日志，确认位置是否被覆盖
   - 如果被覆盖，增加延迟时间（当前是1秒）或使用更晚的事件（如 `OnDailyTick`）


