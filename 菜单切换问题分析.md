# 菜单切换问题分析

## 问题描述

用户选择了"迁徙王族"后，直接看到了"你的家族来自哪个部族"的菜单（Node 2），而不是先看到"你为何流亡？"的菜单（Node 1）。

## 可能的原因

### 1. `preset_origin_selection` 菜单的 OutputMenuId 问题

`preset_origin_selection` 菜单的 `OutputMenuId` 可能被设置为 `"narrative_parent_menu"` 或其他值，而不是 `"wandering_prince_node1"`。

**检查点：**
- `preset_origin_selection` 菜单的 `OutputMenuId` 应该是什么？
- 当用户选择"迁徙王族"选项时，`OnNarrativeMenuOptionSelected` 会先执行，然后引擎可能会根据 `CurrentMenu.OutputMenuId` 自动切换到下一个菜单。

### 2. `OnNarrativeMenuOptionSelectedPatch` Postfix 执行时机问题

`OnNarrativeMenuOptionSelected` 的执行流程：
1. 引擎调用 `OnNarrativeMenuOptionSelected(option)`
2. 引擎内部：`SelectedOptions[CurrentMenu] = option`
3. 引擎内部：`option.OnSelect(this)` ← 这里会调用我们的 `WanderingPrinceOnSelect`
4. 引擎内部：可能自动调用 `TrySwitchToNextMenu()` 或根据 `OutputMenuId` 切换菜单
5. **我们的 Postfix 执行** ← 可能太晚了

### 3. `wandering_prince_subnode` 的 InputMenuId 问题

`wandering_prince_subnode`（Node 2）的 `InputMenuId` 可能仍然是 `"preset_origin_selection"`，导致引擎直接跳转到它。

**当前代码：**
```csharp
var menu = new NarrativeMenu(
    "wandering_prince_subnode",
    "wandering_prince_node1",  // InputMenuId：从Node 1来
    "wandering_prince_node3",  // OutputMenuId：下一步到Node 3
    ...
);
```

这个看起来是对的，但可能旧的菜单还在，或者菜单注册顺序有问题。

## 解决方案

### 方案1：修改 `preset_origin_selection` 菜单的 OutputMenuId

`preset_origin_selection` 菜单的 `OutputMenuId` 应该保持为 `"narrative_parent_menu"`（默认值），因为实际的菜单切换应该由我们的 Postfix 处理。

**但是**，如果引擎在 `OnNarrativeMenuOptionSelected` 内部自动调用 `TrySwitchToNextMenu()`，它会根据 `CurrentMenu.OutputMenuId` 查找下一个菜单。

### 方案2：在 Postfix 中阻止引擎的自动切换

我们需要在 Postfix 中：
1. 检查 `PendingMenuSwitch` 是否已设置
2. 如果已设置，阻止引擎的自动切换（可能需要修改 `CurrentMenu.OutputMenuId` 或使用其他方法）

### 方案3：修改菜单的 InputMenuId/OutputMenuId 链

确保所有菜单的 InputMenuId 和 OutputMenuId 正确连接：
- `preset_origin_selection` → `wandering_prince_node1`（通过 Postfix 手动切换）
- `wandering_prince_node1` → `wandering_prince_subnode`（Node 2）
- `wandering_prince_subnode` → `wandering_prince_node3`
- `wandering_prince_node3` → `wandering_prince_node4`
- `wandering_prince_node4` → `narrative_parent_menu`

## 调试建议

1. **添加更多日志**：在 `OnNarrativeMenuOptionSelectedPatch` 的 Postfix 中添加日志，查看：
   - `PendingMenuSwitch` 的值
   - `CurrentMenu` 的 `StringId` 和 `OutputMenuId`
   - `targetMenu` 的 `StringId` 和 `InputMenuId`
   - `TrySwitchToNextMenu()` 的返回值

2. **检查菜单注册顺序**：确保所有菜单都在 `AddParentsMenuPatch` 中正确注册。

3. **检查是否有旧菜单残留**：确保 `wandering_prince_subnode` 的 `InputMenuId` 不是 `"preset_origin_selection"`。

## 当前代码状态

- ✅ `WanderingPrinceOnSelect` 正确设置了 `PendingMenuSwitch = "wandering_prince_node1"`
- ✅ `wandering_prince_node1` 菜单已创建，`InputMenuId = "preset_origin_selection"`
- ✅ `wandering_prince_subnode` 菜单的 `InputMenuId = "wandering_prince_node1"`（已修复）
- ✅ `OnNarrativeMenuOptionSelectedPatch` Postfix 已实现

## 可能的问题

最可能的问题是：**引擎在 Postfix 执行之前就已经根据 `preset_origin_selection` 菜单的 `OutputMenuId` 自动切换了菜单**。

如果 `preset_origin_selection` 菜单的 `OutputMenuId` 是 `"narrative_parent_menu"`，但引擎内部有逻辑会根据选项的某些属性自动切换，那么可能会跳过我们的 Postfix。

## 建议的修复

在 `OnNarrativeMenuOptionSelectedPatch` 的 Postfix 中，**先检查并阻止引擎的自动切换**，然后再手动切换：

```csharp
static void Postfix(CharacterCreationManager __instance, NarrativeMenuOption option)
{
    if (_isSwitching) return;
    
    if (string.IsNullOrEmpty(OriginSystemHelper.PendingMenuSwitch))
    {
        return;
    }
    
    try
    {
        _isSwitching = true;
        string targetMenuId = OriginSystemHelper.PendingMenuSwitch;
        OriginSystemHelper.PendingMenuSwitch = null;
        
        // 立即获取目标菜单并切换，不要依赖引擎的自动切换
        var targetMenu = __instance.GetNarrativeMenuWithId(targetMenuId);
        if (targetMenu != null)
        {
            // 直接使用反射切换，不依赖 TrySwitchToNextMenu
            SwitchMenuManually(__instance, targetMenu);
        }
    }
    finally
    {
        _isSwitching = false;
    }
}
```

或者，我们需要在 `OnSelect` 回调中**阻止引擎继续处理**，但这可能不可行。











































