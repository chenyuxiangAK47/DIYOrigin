# OriginSystemMod 崩溃分析：无限循环调用问题

## 问题描述

在角色创建界面选择"预设出身"选项后，游戏立即闪退。日志显示 `PresetOriginOnSelect` 方法被无限循环调用。

## 日志信息

### 关键日志片段

```
[19:08:36.377] [OriginSystem] 用户选择了'预设出身' 
[19:08:36.377] [OriginSystem] 用户选择了'预设出身' 
[19:08:36.377] [OriginSystem] 用户选择了'预设出身' 
...（重复数百次）...
```

### 错误特征

- **无限循环**：`PresetOriginOnSelect` 方法被反复调用
- **无异常堆栈**：日志中没有看到异常堆栈信息，只有重复的 Debug.Print
- **闪退**：游戏在循环过程中直接崩溃

## 代码分析

### 当前实现（有问题的版本）

```csharp
private static void PresetOriginOnSelect(CharacterCreationManager characterCreationManager)
{
    try
    {
        Debug.Print("[OriginSystem] 用户选择了'预设出身'", 0, Debug.DebugColor.Green);
        OriginSystemHelper.IsPresetOrigin = true;
        
        // 关键：必须先获取当前菜单和选项，然后调用 OnNarrativeMenuOptionSelected 记录选择
        var currentMenu = characterCreationManager.CurrentMenu;
        if (currentMenu != null)
        {
            // 找到"预设出身"选项
            var presetOption = currentMenu.CharacterCreationMenuOptions.FirstOrDefault(
                opt => opt.StringId == "preset_origin_option");
            if (presetOption != null)
            {
                // 先记录选择（这会添加到 SelectedOptions 字典）
                characterCreationManager.OnNarrativeMenuOptionSelected(presetOption);  // ⚠️ 问题在这里
                Debug.Print("[OriginSystem] 已记录'预设出身'选择", 0, Debug.DebugColor.Green);
            }
        }
        
        // 切换到预设出身选择菜单
        // ... 后续代码
    }
    catch (Exception ex)
    {
        Debug.Print("[OriginSystem] PresetOriginOnSelect 失败: " + ex.Message, 0, Debug.DebugColor.Red);
    }
}
```

### 问题根源

根据反编译代码，`OnNarrativeMenuOptionSelected` 的实现是：

```csharp
public void OnNarrativeMenuOptionSelected(NarrativeMenuOption option)
{
    SelectedOptions[CurrentMenu] = option;
    option.OnSelect(this);  // ⚠️ 这里会调用 PresetOriginOnSelect
}
```

**死循环流程：**

1. 用户点击"预设出身"按钮
2. UI 层调用 `OnNarrativeMenuOptionSelected(presetOption)`
3. `OnNarrativeMenuOptionSelected` 内部调用 `option.OnSelect(this)` → 触发 `PresetOriginOnSelect`
4. `PresetOriginOnSelect` 中又调用 `OnNarrativeMenuOptionSelected(presetOption)` → **回到步骤 2，形成死循环**

### 为什么会出现死循环？

- `PresetOriginOnSelect` 是 `NarrativeMenuOption` 的 `OnSelect` 回调
- 当 UI 层调用 `OnNarrativeMenuOptionSelected` 时，它已经会调用 `OnSelect`
- 在 `OnSelect` 回调内部再次调用 `OnNarrativeMenuOptionSelected`，就会形成递归调用

## 解决方案

### 方案 1：不要在 OnSelect 中调用 OnNarrativeMenuOptionSelected（推荐）

`OnSelect` 回调应该只负责：
1. 保存用户选择的状态（如 `OriginSystemHelper.IsPresetOrigin = true`）
2. 切换菜单（通过反射设置 `CurrentMenu`）

**不应该**：
- 再次调用 `OnNarrativeMenuOptionSelected`（因为 UI 层已经调用过了）

### 修复后的代码

```csharp
private static void PresetOriginOnSelect(CharacterCreationManager characterCreationManager)
{
    try
    {
        Debug.Print("[OriginSystem] 用户选择了'预设出身'", 0, Debug.DebugColor.Green);
        OriginSystemHelper.IsPresetOrigin = true;
        
        // ⚠️ 不要在这里调用 OnNarrativeMenuOptionSelected
        // UI 层已经调用过了，这里只需要处理业务逻辑
        
        // 切换到预设出身选择菜单
        var presetMenu = characterCreationManager.GetNarrativeMenuWithId("preset_origin_selection");
        if (presetMenu != null)
        {
            // 使用反射设置 CurrentMenu
            var currentMenuField = typeof(CharacterCreationManager).GetField("CurrentMenu",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            if (currentMenuField != null)
            {
                currentMenuField.SetValue(characterCreationManager, presetMenu);
                // 调用 ModifyMenuCharacters
                var modifyMethod = typeof(CharacterCreationManager).GetMethod("ModifyMenuCharacters",
                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                modifyMethod?.Invoke(characterCreationManager, null);
                Debug.Print("[OriginSystem] 已切换到预设出身选择菜单", 0, Debug.DebugColor.Green);
            }
        }
    }
    catch (Exception ex)
    {
        Debug.Print("[OriginSystem] PresetOriginOnSelect 失败: " + ex.Message, 0, Debug.DebugColor.Red);
        Debug.Print("[OriginSystem] StackTrace: " + ex.StackTrace, 0, Debug.DebugColor.Red);
    }
}
```

### 方案 2：使用标志位防止递归

如果确实需要在 `OnSelect` 中调用某些方法，可以添加标志位防止递归：

```csharp
private static bool _isProcessingPresetOrigin = false;

private static void PresetOriginOnSelect(CharacterCreationManager characterCreationManager)
{
    if (_isProcessingPresetOrigin)
    {
        Debug.Print("[OriginSystem] 警告：PresetOriginOnSelect 正在处理中，跳过递归调用", 0, Debug.DebugColor.Yellow);
        return;
    }
    
    try
    {
        _isProcessingPresetOrigin = true;
        // ... 原有逻辑
    }
    finally
    {
        _isProcessingPresetOrigin = false;
    }
}
```

## 其他需要注意的问题

### 1. SelectedOptions 字典的维护

`OnNarrativeMenuOptionSelected` 会自动将选择添加到 `SelectedOptions` 字典中，所以不需要在 `OnSelect` 中手动添加。

### 2. 菜单切换的正确方式

菜单切换应该通过：
- 反射设置 `CurrentMenu` 字段
- 调用 `ModifyMenuCharacters()` 方法

或者：
- 使用 `TrySwitchToNextMenu()`（但需要确保菜单链正确连接）

### 3. 菜单链的连接

菜单链通过 `InputMenuId` 连接：
- 菜单 A 的 `StringId = "menu_a"`
- 菜单 B 的 `InputMenuId = "menu_a"`
- 从菜单 A 选择后，`TrySwitchToNextMenu()` 会查找 `InputMenuId == "menu_a"` 的菜单，即菜单 B

## 需要 ChatGPT 确认的问题

1. **`OnSelect` 回调的调用时机**：`OnSelect` 是在 `OnNarrativeMenuOptionSelected` 内部被调用的吗？还是 UI 层直接调用？
2. **`SelectedOptions` 字典的维护**：`OnNarrativeMenuOptionSelected` 是否已经自动将选择添加到字典中？还是需要手动添加？
3. **菜单切换的最佳实践**：在 `OnSelect` 回调中，应该使用反射直接设置 `CurrentMenu`，还是应该通过其他方式（如 `TrySwitchToNextMenu`）？
4. **防止递归调用的最佳方式**：是否有更好的方式防止 `OnSelect` 回调中的递归调用？

## 相关文件

- `OriginSystemMod/SubModule/OriginSystemPatches.cs` - 包含 `PresetOriginOnSelect` 和 `NonPresetOriginOnSelect` 方法
- `D:\Bannerlord_Decompiled\TaleWorlds.CampaignSystem\TaleWorlds.CampaignSystem.CharacterCreationContent\CharacterCreationManager.cs` - 反编译的游戏源码

## 下一步

1. 修复 `PresetOriginOnSelect` 和 `NonPresetOriginOnSelect`，移除对 `OnNarrativeMenuOptionSelected` 的调用
2. 重新编译并测试
3. 如果仍有问题，检查菜单链的连接是否正确











































