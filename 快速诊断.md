# 快速诊断和修复指南

## 给 Cursor 的指令（已创建）

已创建 `给Cursor的硬性指令.md`，可以直接复制发给 Cursor。

## 当前状态

- ✅ 已修复 600+ 个包含裸换行的字符串
- ✅ 已清理乱码替换符和花引号
- ✅ Linter 显示无错误

## 如果还有编译错误，按以下步骤诊断

### 步骤1：定位第一个错误

```powershell
# 编译并查看第一个错误
cd "D:\SteamLibrary\steamapps\common\Mount & Blade II Bannerlord\Modules\OriginSystemMod"
msbuild OriginSystemMod.csproj /p:Configuration=Release /p:Platform=x64 /nologo /v:minimal 2>&1 | Select-Object -First 10
```

### 步骤2：检查第一个 CS1010 错误行

如果第一个错误是 CS1010（常量中有换行符），检查该行的字符串：

```csharp
// 错误示例
new TextObject("第一行
第二行")  // ❌ 裸换行导致 CS1010

// 修复方法1：使用转义
new TextObject("第一行\\n第二行")  // ✅

// 修复方法2：使用逐字字符串
new TextObject(@"第一行
第二行")  // ✅
```

### 步骤3：清理致命字符

```powershell
# 搜索乱码替换符
Select-String -Path "SubModule\OriginSystemPatches.cs" -Pattern "\ufffd" | Select-Object -First 10

# 搜索花引号
Select-String -Path "SubModule\OriginSystemPatches.cs" -Pattern "[""]" | Select-Object -First 10
```

### 步骤4：验证字符串闭合

```powershell
# 检查 TextObject 是否成对
$content = Get-Content "SubModule\OriginSystemPatches.cs" -Raw
$opens = ([regex]::Matches($content, 'new TextObject\("')).Count
$closes = ([regex]::Matches($content, '",\s*\)')).Count + ([regex]::Matches($content, '"\s*\)')).Count
Write-Host "TextObject opens: $opens, closes: $closes"
```

## 修复模板

### 模板1：修复包含换行的 TextObject

```csharp
// 修复前（CS1010）
new TextObject("选择你的出身类型：预设出身（带剧本、带势力）或非预设出身（自由拼装
）。"),

// 修复后
new TextObject("选择你的出身类型：预设出身（带剧本、带势力）或非预设出身（自由拼装）。"),
```

### 模板2：修复多行文本

```csharp
// 修复前（CS1010）
new TextObject("第一行
第二行
第三行"),

// 修复后（方法1：转义）
new TextObject("第一行\\n第二行\\n第三行"),

// 修复后（方法2：逐字字符串）
new TextObject(@"第一行
第二行
第三行"),
```

## 关键错误位置（基于 debugLog.md）

根据日志，需要重点检查：

- **3553行**：第一个 CS1010 错误
- **3697行**：CS1010 错误
- **3877行**：CS1010 错误
- **3401行**：CS1056 意外字符 ``
- **4201, 4471, 4489行**：CS1513 应输入 }
- **4921行**：CS1026 应输入 )

这些错误往往是连锁反应，修复第一个后，后面的会自动消失。










































