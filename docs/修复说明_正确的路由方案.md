# 修复说明：正确的路由方案

## 核心问题

之前的方案**完全错误**：
- ❌ 试图修改 `OutputMenuId`（可能是只读的）
- ❌ 在 `OnNarrativeMenuOptionSelected` 中修改（时序不对）
- ❌ 没有确认引擎实际使用什么字段来选择下一个菜单

## 正确的方案

### 1. 在 `TrySwitchToNextMenu` 的 Prefix 中做路由

**为什么**：
- `TrySwitchToNextMenu` 是引擎真正切换菜单的地方
- 此时 `SelectedOptions` 已经更新，可以读取用户的选择
- 可以阻止原版逻辑执行，避免"第一个匹配"的问题

### 2. 直接设置 `CurrentMenu`，而不是修改 `OutputMenuId`

**为什么**：
- `OutputMenuId` 可能是只读的，修改可能无效
- 引擎可能不是用 `OutputMenuId` 来找下一个菜单
- 直接设置 `CurrentMenu` 更可靠

### 3. 使用反射枚举找到 `CurrentMenu` 的 backing field

**为什么**：
- 不要硬写字段名（可能猜错）
- 枚举所有字段，找到 `NarrativeMenu` 类型的字段
- 如果字段方式失败，尝试属性的 setter

## 实现细节

### 路由逻辑

```csharp
// A) 出身类型选择：分流预设/非预设
if (cm.StringId == "origin_type_selection")
{
    var opt = SelectedOptions[cm];
    if (opt.StringId == "non_preset_origin_option")
        nextId = "non_preset_culture_anchor";
    else if (opt.StringId == "preset_origin_option")
        nextId = "preset_origin_selection";
}

// B) 预设出身选择：按选项分流到不同 Node1
if (cm.StringId == "preset_origin_selection")
{
    var opt = SelectedOptions[cm];
    switch (opt.StringId)
    {
        case "khuzait_wandering_prince":
            nextId = "wandering_prince_node1";
            break;
        case "khuzait_slave_escape":
            nextId = "slave_escape_node1";
            break;
    }
}
```

### 强制切换菜单

```csharp
static bool ForceSwitch(CharacterCreationManager mgr, string targetMenuId, ref bool __result)
{
    var target = mgr.GetNarrativeMenuWithId(targetMenuId);
    if (target == null) return true; // 让原版处理
    
    if (!TrySetCurrentMenuByReflection(mgr, target))
        return true; // 让原版处理
    
    InvokeModifyMenuCharacters(mgr);
    
    __result = true;
    return false; // 阻止原版 TrySwitchToNextMenu 继续执行
}
```

### 反射设置 CurrentMenu

```csharp
static bool TrySetCurrentMenuByReflection(CharacterCreationManager mgr, NarrativeMenu target)
{
    // 1. 先尝试找字段
    var fields = typeof(CharacterCreationManager).GetFields(flags);
    foreach (var f in fields)
    {
        if (typeof(NarrativeMenu).IsAssignableFrom(f.FieldType))
        {
            f.SetValue(mgr, target);
            return true;
        }
    }
    
    // 2. 如果字段方式失败，尝试属性的 setter
    var prop = typeof(CharacterCreationManager).GetProperty("CurrentMenu", flags);
    if (prop != null && prop.CanWrite)
    {
        prop.SetValue(mgr, target);
        return true;
    }
    
    return false;
}
```

## 详细日志

### 1. OnNarrativeMenuOptionSelected Postfix 日志

- 当前菜单的 StringId、InputMenuId、OutputMenuId
- 选项的 StringId 和 Text
- SelectedOptions 是否包含当前菜单
- SelectedOption 的值

### 2. TrySwitchToNextMenu Prefix 日志

- 当前菜单的完整信息
- SelectedOptions 的状态
- **候选下一个菜单列表**（按 InputMenuId 匹配）
- 路由决策过程
- 强制切换的结果

### 3. 反射操作日志

- 找到的字段名和类型
- 设置是否成功
- ModifyMenuCharacters 的调用情况

## 关键改进

1. ✅ **不再修改 OutputMenuId**：直接设置 CurrentMenu
2. ✅ **在正确的时机做路由**：TrySwitchToNextMenu Prefix
3. ✅ **使用 SelectedOptions**：读取用户的实际选择
4. ✅ **阻止原版逻辑**：return false 避免"第一个匹配"
5. ✅ **详细的日志**：CandidateNext 列表、路由过程、反射操作

## 测试建议

1. **编译并运行游戏**
2. **选择"预设出身"**，查看日志：
   - 应该看到路由到 `preset_origin_selection`
   - CandidateNext 列表应该包含所有预设出身菜单
3. **选择"非预设出身"**，查看日志：
   - 应该看到路由到 `non_preset_culture_anchor`
   - CandidateNext 列表应该只包含非预设菜单
4. **选择"迁徙王族"**，查看日志：
   - 应该看到路由到 `wandering_prince_node1`
   - 应该看到强制切换成功的日志

## 代码位置

- **TrySwitchToNextMenu Prefix**：`OriginSystemPatches.cs` 第 5540-5812 行
- **OnNarrativeMenuOptionSelected Postfix**：`OriginSystemPatches.cs` 第 5518-5550 行
- **旧的错误 Prefix**：已注释掉
























































