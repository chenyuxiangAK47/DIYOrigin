# 问题分析：选择非预设出身却走预设流程（修复版）

## 问题描述

用户在选择"非预设出身"选项时，游戏却进入了预设出身的流程（显示预设出身的选项菜单）。

## 根本原因分析

### 核心问题：时序错误

**关键发现**：`OnNarrativeMenuOptionSelected` 的执行顺序是：
1. **Prefix 先执行**
2. **引擎处理选项**
3. **OnSelect 回调后执行**

**问题代码**：
```csharp
// Prefix 中
if (string.IsNullOrEmpty(OriginSystemHelper.PendingMenuSwitch)) return;
var targetMenuId = OriginSystemHelper.PendingMenuSwitch;  // ❌ 这里读到的是"上一次"的值
```

```csharp
// OnSelect 回调中（在 Prefix 之后执行）
OriginSystemHelper.PendingMenuSwitch = "non_preset_culture_anchor";  // ❌ Prefix 已经执行完了，看不到这个值
```

**结果**：
- Prefix 执行时，`PendingMenuSwitch` 还是上一次的值（或为空）
- 如果上一次选择的是预设出身，`PendingMenuSwitch` 就是 `"preset_origin_selection"`
- 所以即使这次选择非预设，Prefix 也会按预设路径走

### 次要问题：OutputMenuId 设置错误

**错误代码**：
```csharp
outputMenuIdField.SetValue(__instance.CurrentMenu, targetMenu.InputMenuId);  // ❌ 错误
```

**问题**：
- `preset_origin_selection` 和 `non_preset_culture_anchor` 的 `InputMenuId` 都是 `"origin_type_selection"`
- 所以无论设置哪个，结果都一样，无法分流

**正确做法**：
```csharp
outputMenuIdField.SetValue(__instance.CurrentMenu, targetMenuId);  // ✅ 使用 StringId
```

## 修复方案

### 方案 1：在 Prefix 中直接根据 option.StringId 决定目标菜单（已实现）

**核心思路**：不依赖 `PendingMenuSwitch`，直接在 Prefix 中根据 `option.StringId` 决定目标菜单。

**修复后的 Prefix**：
```csharp
static void Prefix(CharacterCreationManager __instance, NarrativeMenuOption option)
{
    if (_isSwitching) return;
    if (__instance.CurrentMenu == null || option == null) return;

    var currentMenuId = __instance.CurrentMenu.StringId;
    var optionId = option.StringId;
    
    // 根据 option.StringId 直接决定目标菜单
    string targetMenuId = null;
    
    if (currentMenuId == "origin_type_selection")
    {
        if (optionId == "preset_origin_option")
        {
            targetMenuId = "preset_origin_selection";
        }
        else if (optionId == "non_preset_origin_option")
        {
            targetMenuId = "non_preset_culture_anchor";
        }
    }
    
    if (string.IsNullOrEmpty(targetMenuId)) return;
    
    var targetMenu = __instance.GetNarrativeMenuWithId(targetMenuId);
    if (targetMenu == null) return;
    
    // 使用目标菜单的 StringId 作为 OutputMenuId
    var outputMenuIdField = typeof(NarrativeMenu).GetField("OutputMenuId",
        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
    
    if (outputMenuIdField != null)
    {
        var originalOutputMenuId = __instance.CurrentMenu.OutputMenuId;
        outputMenuIdField.SetValue(__instance.CurrentMenu, targetMenuId);
        
        Debug.Print($"[OriginSystem] Prefix: 当前菜单={currentMenuId}, 选项={optionId}, 目标菜单={targetMenuId}", 0, Debug.DebugColor.Green);
        Debug.Print($"[OriginSystem] Prefix: 修改 OutputMenuId: {originalOutputMenuId} -> {targetMenuId}", 0, Debug.DebugColor.Yellow);
    }
}
```

**优点**：
- ✅ 不依赖 `PendingMenuSwitch`，避免时序问题
- ✅ 直接根据选项 ID 路由，逻辑清晰
- ✅ 使用 `StringId` 作为 `OutputMenuId`，正确分流

### 方案 2：添加 TrySwitchToNextMenu 的 Postfix 调试（已实现）

**目的**：确认引擎实际切换到了哪个菜单。

```csharp
[HarmonyPatch(typeof(CharacterCreationManager), "TrySwitchToNextMenu")]
public static class TrySwitchToNextMenuPatch
{
    static void Postfix(CharacterCreationManager __instance, bool __result)
    {
        if (__instance.CurrentMenu != null)
        {
            Debug.Print($"[OriginSystem] TrySwitchToNextMenu Postfix: 切换结果={__result}, 当前菜单={__instance.CurrentMenu.StringId}, OutputMenuId={__instance.CurrentMenu.OutputMenuId}", 0, Debug.DebugColor.Cyan);
        }
    }
}
```

## 需要确认的引擎机制

1. **TrySwitchToNextMenu() 的匹配逻辑**：
   - 是根据 `CurrentMenu.OutputMenuId` 匹配菜单的 `StringId` 吗？
   - 还是匹配 `InputMenuId`？
   - 如果多个菜单有相同的 `InputMenuId`，如何选择？

2. **菜单查找顺序**：
   - 引擎是按注册顺序查找，还是按其他规则？
   - 如果 `OutputMenuId` 匹配多个菜单的 `StringId`，会选哪个？

## 调试建议

运行游戏后，查看日志输出：

1. **Prefix 日志**：
   - `[OriginSystem] Prefix: 当前菜单=origin_type_selection, 选项=non_preset_origin_option, 目标菜单=non_preset_culture_anchor`
   - `[OriginSystem] Prefix: 修改 OutputMenuId: preset_origin_selection -> non_preset_culture_anchor`

2. **TrySwitchToNextMenu Postfix 日志**：
   - `[OriginSystem] TrySwitchToNextMenu Postfix: 切换结果=True, 当前菜单=non_preset_culture_anchor, OutputMenuId=non_preset_social_origin`

3. **如果还是走预设流程**：
   - 检查 Prefix 是否被调用
   - 检查 `targetMenu` 是否找到
   - 检查 `OutputMenuId` 是否被正确修改

## 代码位置

- **修复后的 Prefix**：`OriginSystemPatches.cs` 第 5507-5582 行
- **TrySwitchToNextMenu Postfix**：`OriginSystemPatches.cs` 第 5602-5615 行
- **非预设出身选择回调**：`OriginSystemPatches.cs` 第 695-707 行（现在只设置状态，不负责菜单切换）
- **预设出身选择回调**：`OriginSystemPatches.cs` 第 630-642 行（现在只设置状态，不负责菜单切换）

## 总结

**根本原因**：Prefix 在 OnSelect 之前执行，无法读取本次点击设置的 `PendingMenuSwitch`。

**解决方案**：在 Prefix 中直接根据 `option.StringId` 决定目标菜单，不依赖 `PendingMenuSwitch`。

**关键修复**：
1. ✅ Prefix 中根据 `option.StringId` 直接路由
2. ✅ 使用 `targetMenuId`（StringId）作为 `OutputMenuId`
3. ✅ 添加 `TrySwitchToNextMenu` Postfix 调试日志
4. ✅ 清理 Postfix 中遗留的 `PendingMenuSwitch`

























































