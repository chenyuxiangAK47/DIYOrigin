# 逃奴出生位置设置未生效问题分析

## 问题描述

选择逃奴出身后，选择"沙漠深处"或"逃亡帝国"时，出生位置没有正确设置。玩家仍然在默认位置出生，而不是在预期的沙漠城市或帝国最南端城市。

## 代码架构

### 1. 数据流

```
用户选择方向 (Node5 OnSelect)
  ↓
SaveSlaveEscapeStartingLocation() 
  ↓ 保存到 OriginSystemHelper
OriginSystemHelper.PendingStartDirection = "desert" | "empire"
OriginSystemHelper.PendingStartSettlementId = null
  ↓
游戏开始 (OnSessionLaunched)
  ↓
ApplyPresetOrigin() → ApplySlaveEscapeOrigin() → ApplySlaveEscapeNode5()
  ↓ (只应用技能，不设置位置)
延迟执行 (OnTick, 延迟1秒)
  ↓
SetSlaveEscapeStartingLocation() → 查找 settlement → teleport
```

### 2. 关键代码位置

#### A. Node 选择时保存 (SlaveEscapeNodes.cs)

```csharp
private static void SlaveDirectionDesertOnSelect(CharacterCreationManager manager) 
{ 
    OriginLog.Info("用户选择战奴逃亡-Node5-留沙"); 
    OriginSystemHelper.SelectedPresetOriginNodes["khz_node_ex_slave_direction"] = "desert"; 
    OriginSystemHelper.OriginSelectionDone = true; 
    
    // 保存期望出生位置：沙漠深处（阿塞莱的沙漠城市）
    SaveSlaveEscapeStartingLocation("desert");
}

private static void SaveSlaveEscapeStartingLocation(string direction)
{
    try
    {
        // 在角色创建阶段，Campaign.Current 可能还不存在，所以只保存 direction
        // 实际的 settlement 查找和位置设置会在游戏开始后执行
        OriginSystemHelper.PendingStartDirection = direction;
        OriginSystemHelper.PendingStartSettlementId = null; // 延迟到游戏开始后查找
        
        OriginLog.Info($"[SlaveEscape][Node5] 已保存期望出生位置: direction={direction}");
    }
    catch (Exception ex)
    {
        OriginLog.Error($"[SlaveEscape][Node5] 保存出生位置时出错: {ex.Message}");
    }
}
```

#### B. 延迟执行逻辑 (OriginSystemCampaignBehavior.cs)

```csharp
private void OnTick(float dt)
{
    // 验证下一帧的位置（如果已设置 teleport）
    if (_verifyNextTick)
    {
        if (MobileParty.MainParty != null)
        {
            var posProp = typeof(MobileParty).GetProperty("Position2D", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
            if (posProp != null)
            {
                var currentPos = (Vec2)posProp.GetValue(MobileParty.MainParty);
                OriginLog.Info($"[SlaveEscape][VerifyNextTick] pos=({currentPos.X:F2},{currentPos.Y:F2})");
            }
        }
        _verifyNextTick = false;
        return;
    }

    // 延迟执行逃奴出生位置设置
    // 注意：PendingStartSettlementId 可能为 null（在 node 中只保存了 direction），需要在 SetSlaveEscapeStartingLocation 中查找
    if (!_hasSetSlaveEscapePosition && 
        !string.IsNullOrEmpty(OriginSystemHelper.PendingStartDirection))
    {
        _teleportDelay += dt;
        
        // 等待延迟时间，确保地图和队伍已完全初始化
        if (_teleportDelay >= TELEPORT_DELAY_SECONDS)
        {
            try
            {
                if (Hero.MainHero != null && MobileParty.MainParty != null && Campaign.Current != null)
                {
                    var direction = OriginSystemHelper.PendingStartDirection;
                    var settlementId = OriginSystemHelper.PendingStartSettlementId; // 可能为 null

                    OriginLog.Info($"[SlaveEscape][Teleport] 开始延迟执行: direction={direction} settlementId={settlementId ?? "null"}");

                    // 执行 teleport（settlementId 可能为 null，会在方法内查找）
                    PresetOriginSystem.SetSlaveEscapeStartingLocation(
                        MobileParty.MainParty, 
                        direction, 
                        settlementId
                    );

                    // 标记下一帧验证位置
                    _verifyNextTick = true;
                    
                    _hasSetSlaveEscapePosition = true;
                    OriginSystemHelper.PendingStartDirection = null;
                    OriginSystemHelper.PendingStartSettlementId = null;
                }
                else
                {
                    OriginLog.Info($"[SlaveEscape][Teleport] 等待条件满足: mainHero={Hero.MainHero != null} mainParty={MobileParty.MainParty != null} campaign={Campaign.Current != null}");
                }
            }
            catch (Exception ex)
            {
                OriginLog.Error($"[SlaveEscape][Teleport] 延迟执行失败: {ex.Message}");
                OriginLog.Error($"[SlaveEscape][Teleport] StackTrace: {ex.StackTrace}");
            }
        }
    }
}
```

#### C. Teleport 执行逻辑 (PresetOriginSystem.cs)

```csharp
public static void SetSlaveEscapeStartingLocation(MobileParty party, string direction, string settlementId = null)
{
    if (party == null)
    {
        OriginLog.Error("[SlaveEscape][Teleport] MainParty 为空，无法设置出生位置");
        return;
    }

    try
    {
        Settlement targetSettlement = null;

        // 优先使用传入的 settlementId，否则重新查找
        if (!string.IsNullOrEmpty(settlementId))
        {
            targetSettlement = Campaign.Current?.Settlements?.FirstOrDefault(s => s.StringId == settlementId);
        }

        // 如果 settlementId 为空，重新查找
        if (targetSettlement == null)
        {
            if (direction == "desert")
            {
                // 寻找阿塞莱的沙漠城市（选择最靠近沙漠深处的城市）
                targetSettlement = Campaign.Current?.Settlements?
                    .Where(s => s.IsTown && s.Culture?.StringId == "aserai")
                    .OrderByDescending(s => s.Position.Y) // Y轴越大越靠南（沙漠深处）
                    .FirstOrDefault();

                if (targetSettlement == null)
                {
                    // 如果找不到，尝试通过ID查找
                    targetSettlement = Campaign.Current?.Settlements?.FirstOrDefault(s => 
                        s.StringId == "town_AN1" || // Quyaz
                        s.StringId == "town_AN2" || // Sanala
                        s.StringId == "town_AN3");  // Husn Fulq
                }
            }
            else if (direction == "empire")
            {
                // 寻找帝国最南端的城市
                targetSettlement = Campaign.Current?.Settlements?
                    .Where(s => s.IsTown && s.Culture?.StringId == "empire")
                    .OrderByDescending(s => s.Position.Y) // Y轴越大越靠南
                    .FirstOrDefault();

                if (targetSettlement == null)
                {
                    // 如果找不到，尝试通过ID查找
                    targetSettlement = Campaign.Current?.Settlements?.FirstOrDefault(s => 
                        s.StringId == "town_ES1" || // Poros
                        s.StringId == "town_ES2" || // Lycaron
                        s.StringId == "town_ES3");  // Ortysia
                }
            }
            
            // 如果找到了，更新 settlementId
            if (targetSettlement != null && string.IsNullOrEmpty(settlementId))
            {
                OriginSystemHelper.PendingStartSettlementId = targetSettlement.StringId;
                OriginLog.Info($"[SlaveEscape][Teleport] 找到目标定居点: {targetSettlement.StringId} ({targetSettlement.Name})");
            }
        }

        if (targetSettlement == null)
        {
            OriginLog.Warning($"[SlaveEscape][Teleport] 未找到目标定居点 (direction: {direction}, settlementId: {settlementId})");
            return;
        }

        // [SlaveEscape][Teleport] 日志：记录 teleport 前的状态
        Vec2 beforePos = Vec2.Invalid;
        var beforePosProp = typeof(MobileParty).GetProperty("Position2D", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
        if (beforePosProp != null)
        {
            beforePos = (Vec2)beforePosProp.GetValue(party);
        }
        OriginLog.Info($"[SlaveEscape][Teleport] when=延迟执行 before=({beforePos.X:F2},{beforePos.Y:F2}) targetSettlement={targetSettlement.StringId} targetName={targetSettlement.Name}");

        // 获取目标位置：优先使用 GatePosition（Vec2），否则使用 Position（CampaignVec2）转换
        Vec2 targetPos;
        try
        {
            // 尝试使用 GatePosition（如果存在）
            var gatePositionProperty = typeof(Settlement).GetProperty("GatePosition", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
            if (gatePositionProperty != null)
            {
                var gatePos = gatePositionProperty.GetValue(targetSettlement);
                if (gatePos is Vec2 gateVec2)
                {
                    targetPos = gateVec2;
                }
                else if (gatePos != null)
                {
                    // 如果是其他类型，尝试转换
                    var gatePosType = gatePos.GetType();
                    var xProp = gatePosType.GetProperty("X") ?? gatePosType.GetProperty("x");
                    var yProp = gatePosType.GetProperty("Y") ?? gatePosType.GetProperty("y");
                    if (xProp != null && yProp != null)
                    {
                        targetPos = new Vec2((float)xProp.GetValue(gatePos), (float)yProp.GetValue(gatePos));
                    }
                    else
                    {
                        throw new Exception("无法从 GatePosition 提取 X/Y");
                    }
                }
                else
                {
                    throw new Exception("GatePosition 为 null");
                }
            }
            else
            {
                // 回退到使用 Position（CampaignVec2）
                var settlementPos = targetSettlement.Position;
                targetPos = new Vec2(settlementPos.X, settlementPos.Y);
            }
        }
        catch (Exception ex)
        {
            // 如果 GatePosition 不可用，使用 Position
            var settlementPos = targetSettlement.Position;
            targetPos = new Vec2(settlementPos.X, settlementPos.Y);
            OriginLog.Info($"[SlaveEscape][Teleport] GatePosition 不可用，使用 Position: {ex.Message}");
        }

        // 在定居点附近随机偏移一点，避免直接重叠
        var random = new Random();
        var randomOffset = new Vec2(
            (float)(random.NextDouble() * 2.0 - 1.0) * 0.5f,
            (float)(random.NextDouble() * 2.0 - 1.0) * 0.5f
        );
        targetPos += randomOffset;

        // 尝试设置位置：优先使用 TeleportPartyAction，否则使用反射
        bool teleportSuccess = false;

        // 方法1：尝试使用 TeleportPartyAction
        try
        {
            var teleportType = Type.GetType("TaleWorlds.CampaignSystem.Actions.TeleportPartyAction, TaleWorlds.CampaignSystem");
            if (teleportType != null)
            {
                var applyMethod = teleportType.GetMethod("Apply", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
                if (applyMethod != null)
                {
                    // 尝试不同的参数签名
                    var parameters = applyMethod.GetParameters();
                    if (parameters.Length == 2 && parameters[0].ParameterType == typeof(MobileParty))
                    {
                        applyMethod.Invoke(null, new object[] { party, targetPos });
                        teleportSuccess = true;
                        OriginLog.Info($"[SlaveEscape][Teleport] 使用TeleportPartyAction.Apply(MobileParty, Vec2)");
                    }
                    else if (parameters.Length == 3)
                    {
                        applyMethod.Invoke(null, new object[] { party, targetPos, targetSettlement });
                        teleportSuccess = true;
                        OriginLog.Info($"[SlaveEscape][Teleport] 使用TeleportPartyAction.Apply(MobileParty, Vec2, Settlement)");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            OriginLog.Info($"[SlaveEscape][Teleport] TeleportPartyAction 不可用: {ex.Message}");
        }

        // 方法2：尝试反射设置 Position2D 属性
        if (!teleportSuccess)
        {
            try
            {
                var positionProperty = typeof(MobileParty).GetProperty("Position2D", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                if (positionProperty != null && positionProperty.CanWrite)
                {
                    positionProperty.SetValue(party, targetPos);
                    teleportSuccess = true;
                    OriginLog.Info($"[SlaveEscape][Teleport] 使用反射设置 Position2D 属性");
                }
            }
            catch (Exception ex)
            {
                OriginLog.Info($"[SlaveEscape][Teleport] Position2D 属性不可写: {ex.Message}");
            }
        }

        // 方法3：尝试反射设置内部字段
        if (!teleportSuccess)
        {
            try
            {
                var positionField = typeof(MobileParty).GetField("_position2D", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                if (positionField != null)
                {
                    positionField.SetValue(party, targetPos);
                    teleportSuccess = true;
                    OriginLog.Info($"[SlaveEscape][Teleport] 使用反射设置 _position2D 字段");
                }
            }
            catch (Exception ex)
            {
                OriginLog.Warning($"[SlaveEscape][Teleport] 无法设置位置: {ex.Message}");
            }
        }

        // 验证设置是否成功
        Vec2 afterPos = Vec2.Invalid;
        var posProp = typeof(MobileParty).GetProperty("Position2D", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
        if (posProp != null)
        {
            afterPos = (Vec2)posProp.GetValue(party);
        }
        OriginLog.Info($"[SlaveEscape][Teleport] after=({afterPos.X:F2},{afterPos.Y:F2}) success={teleportSuccess}");

        // 设置 HomeSettlement
        try
        {
            party.SetHomeSettlement(targetSettlement);
            OriginLog.Info($"[SlaveEscape][Teleport] 已设置 HomeSettlement: {targetSettlement.Name}");
        }
        catch (Exception ex)
        {
            OriginLog.Warning($"[SlaveEscape][Teleport] 设置 HomeSettlement 失败: {ex.Message}");
        }
    }
    catch (Exception ex)
    {
        OriginLog.Error($"[SlaveEscape][Teleport] 设置出生位置时出错: {ex.Message}");
    }
}
```

## 可能的问题原因

### 1. 时机问题 ⚠️ **最可能**

**问题**: `OnTick` 延迟1秒可能还不够，或者游戏引擎在 teleport 之后又重置了位置。

**证据**:
- 代码中使用了 `CampaignEvents.TickEvent`，但可能需要在更晚的时机执行
- 位置设置后可能被引擎的初始化流程覆盖

**需要验证**:
- 查看日志中是否有 `[SlaveEscape][Teleport]` 的输出
- 查看 `[SlaveEscape][VerifyNextTick]` 的位置是否和 `after` 一致

### 2. CampaignBehavior 未注册

**问题**: `OriginSystemCampaignBehavior` 可能没有被正确注册到游戏中。

**需要验证**:
- 检查 `OriginSystemSubModule.cs` 中是否正确添加了 `CampaignBehavior`
- 查看日志中是否有 `[OriginSystem] 已应用预设出身` 的输出

### 3. PendingStartDirection 被清空

**问题**: `PendingStartDirection` 可能在某个地方被意外清空。

**需要验证**:
- 在 `OnTick` 开始时添加日志，检查 `PendingStartDirection` 的值
- 检查 `OriginSystemHelper.ResetState()` 是否在错误时机被调用

### 4. Settlement 查找失败

**问题**: 可能找不到目标 settlement（文化ID错误、settlement 不存在等）。

**需要验证**:
- 查看日志中是否有 `[SlaveEscape][Teleport] 未找到目标定居点` 的输出
- 检查 `Campaign.Current.Settlements` 是否包含预期的 settlement

### 5. Teleport 方法都失败

**问题**: 所有 teleport 方法（TeleportPartyAction、Position2D 属性、_position2D 字段）都失败了。

**需要验证**:
- 查看日志中 `success` 的值
- 查看是否有相关的错误信息

## 调试建议

### 1. 添加更多日志

在以下位置添加日志：

```csharp
// OriginSystemCampaignBehavior.OnTick 开始
OriginLog.Info($"[SlaveEscape][OnTick] 检查: hasSet={_hasSetSlaveEscapePosition} direction={OriginSystemHelper.PendingStartDirection} delay={_teleportDelay:F2}");

// SetSlaveEscapeStartingLocation 开始
OriginLog.Info($"[SlaveEscape][Teleport] 方法被调用: direction={direction} settlementId={settlementId}");

// Settlement 查找后
OriginLog.Info($"[SlaveEscape][Teleport] 找到 settlement: {(targetSettlement != null ? targetSettlement.StringId : "null")}");
```

### 2. 检查 CampaignBehavior 注册

```csharp
// OriginSystemSubModule.cs
protected override void OnGameStart(Game game, IGameStarter gameStarterObject)
{
    if (gameStarterObject is CampaignGameStarter campaignStarter)
    {
        campaignStarter.AddBehavior(new OriginSystemCampaignBehavior());
        OriginLog.Info("[OriginSystem] CampaignBehavior 已注册");
    }
}
```

### 3. 验证时机

尝试使用更晚的事件：

```csharp
// 方案1: 使用 OnDailyTick（每天执行一次）
CampaignEvents.DailyTickEvent.AddNonSerializedListener(this, OnDailyTick);

// 方案2: 使用 OnHourlyTick（每小时执行一次）
CampaignEvents.HourlyTickEvent.AddNonSerializedListener(this, OnHourlyTick);

// 方案3: 使用 OnAfterSessionLaunched（在 OnSessionLaunched 之后）
CampaignEvents.OnAfterSessionLaunchedEvent.AddNonSerializedListener(this, OnAfterSessionLaunched);
```

### 4. 检查数据持久化

确认 `OriginSystemHelper` 的数据在游戏开始后仍然存在：

```csharp
// OnSessionLaunched 中
OriginLog.Info($"[OriginSystem] OnSessionLaunched: PendingStartDirection={OriginSystemHelper.PendingStartDirection}");
```

## 预期日志输出

如果一切正常，应该看到以下日志序列：

### 方案1：OnCharacterCreationFinalized 成功（主方案）

```
[OS] [SlaveEscape][Node5] 已保存期望出生位置: direction=desert
[OriginSystem] 已应用预设出身: slave_escape
[OS] [SlaveEscape][Finalize] OnCharacterCreationFinalized Postfix called
[OS] [SlaveEscape][Finalize] 开始设置出生位置: direction=desert
[OS] [SlaveEscape][Teleport] 阿塞莱城市列表（用于验证 Y 轴方向）:
  - Quyaz (town_AN1) Pos=(450.00,650.00)
  - Sanala (town_AN2) Pos=(420.00,620.00)
  ...
[OS] [SlaveEscape][Teleport] when=OnCharacterCreationFinalized before=(100.00,200.00) targetSettlement=town_AN1 targetName=Quyaz
[OS] [SlaveEscape][Teleport] 使用 Position2D 属性设置位置: success=True
[OS] [SlaveEscape][Teleport] after=(450.00,650.00) success=True
[OS] [SlaveEscape][Finalize] 出生位置设置成功，已清空 Pending
```

### 方案2：OnCharacterCreationFinalized 失败，OnTick 兜底

```
[OS] [SlaveEscape][Finalize] OnCharacterCreationFinalized Postfix called
[OS] [SlaveEscape][Finalize] Hero.MainHero 为空，延迟到 OnTick
[OS] [SlaveEscape][Teleport] 开始兜底重试: direction=desert settlementId=null
[OS] [SlaveEscape][Teleport] when=兜底重试 before=(100.00,200.00) ...
[OS] [SlaveEscape][Teleport] after=(450.00,650.00) success=True
[OS] [SlaveEscape][Teleport] 兜底重试成功，已清空 Pending
[OS] [SlaveEscape][VerifyNextTick] pos=(450.00,650.00)
```

如果 `VerifyNextTick` 的位置和 `after` 不同，说明位置被引擎覆盖了，需要进一步调整时机。

## 已确认的信息

### CampaignBehavior 注册 ✅
```csharp
// OriginSystemSubModule.cs
protected override void OnGameStart(Game game, IGameStarter gameStarter)
{
    base.OnGameStart(game, gameStarter);

    if (game.GameType is Campaign)
    {
        // 添加 CampaignBehavior
        ((CampaignGameStarter)gameStarter).AddBehavior(new OriginSystemCampaignBehavior());
        Debug.Print("[OriginSystem] CampaignBehavior 已添加", 0, Debug.DebugColor.Green);
    }
}
```

### 数据保存 ✅
- `PendingStartDirection` 在 node 的 `OnSelect` 中正确保存
- `PendingStartSettlementId` 设为 `null`（延迟查找）

### 延迟执行逻辑 ✅
- 使用 `CampaignEvents.TickEvent` 延迟1秒执行
- 检查 `Hero.MainHero`、`MobileParty.MainParty`、`Campaign.Current` 是否都存在

## 需要 ChatGPT 帮助的问题

1. **时机问题**: Bannerlord 中设置玩家队伍位置的最佳时机是什么？`OnTick`、`OnHourlyTick`、`OnDailyTick` 还是其他事件？延迟1秒是否足够？

2. **Teleport 方法**: Bannerlord 中正确传送队伍到指定位置的方法是什么？`TeleportPartyAction` 是否存在？如果不存在，应该用什么方法？是否有官方的 teleport API？

3. **位置覆盖**: 如果位置设置后被引擎覆盖，应该如何处理？是否需要使用特定的 flag 或方法？是否需要在设置位置后禁用某些引擎行为？

4. **数据持久化**: `OriginSystemHelper` 的静态数据在游戏开始后是否仍然存在？`OnBeforeInitialModuleScreenSetAsRoot` 中的 `ResetState()` 是否会在游戏开始前清空数据？

5. **Settlement 查找**: `Campaign.Current.Settlements` 在 `OnTick` 时是否已经初始化？文化ID `"aserai"` 和 `"empire"` 是否正确？

6. **Position2D 访问**: 使用反射访问 `MobileParty.Position2D` 是否正确？是否有更好的方法？

7. **GatePosition vs Position**: `Settlement.GatePosition` 和 `Settlement.Position` 的区别是什么？哪个更适合设置队伍位置？

## 已实现的修复（按用户要求）

### ✅ 1. 时机修复：使用 OnCharacterCreationFinalized Postfix（核心修复）

**问题**: 之前在 `OnTick` 延迟执行，时机不对，可能被引擎覆盖

**修复**: 
- 创建了 `OnCharacterCreationFinalizedPatch` Harmony Postfix
- 在角色创建 finalize 时直接设置位置（正确时机）
- `OnTick` 改为兜底逻辑（如果 finalize 失败才重试）

**代码位置**: `OriginSystemPatches.cs` - `OnCharacterCreationFinalizedPatch`

### ✅ 2. 成功标志修复：只有成功才清空 Pending

**问题**: 无论成功失败都清空了 `PendingStartDirection`，导致失败后不会重试

**修复**:
- `SetSlaveEscapeStartingLocation()` 现在返回 `bool success`
- 只有 `success == true` 才清空 `PendingStartDirection` 和 `PendingStartSettlementId`
- 失败时保留状态，允许重试

**代码位置**: 
- `PresetOriginSystem.cs` - `SetSlaveEscapeStartingLocation()` 返回 `bool`
- `OriginSystemCampaignBehavior.cs` - `OnTick` 检查返回值
- `OriginSystemPatches.cs` - `OnCharacterCreationFinalizedPatch` 检查返回值

### ✅ 3. 移除 TeleportPartyAction 猜测

**问题**: 猜测 `TeleportPartyAction` 的类名和签名，可能根本不存在

**修复**:
- 移除了 `TeleportPartyAction` 的猜测代码
- 直接使用 `Position2D` 属性或反射字段（在 finalize 时机，这是最稳定的方法）

### ✅ 4. 添加城市坐标打印（验证 Y 轴方向）

**问题**: Y 轴方向可能是反的（Y 越小越南 vs Y 越大越南）

**修复**:
- 在查找 settlement 时，先打印所有相关城市的坐标
- 便于运行时验证 Y 轴方向是否正确

**代码位置**: `PresetOriginSystem.cs` - `SetSlaveEscapeStartingLocation()` 中

### ✅ 5. 增强可判定日志

**修复**: 添加了完整的可判定日志：
- `[SlaveEscape][Finalize]` - finalize patch 执行日志
- `[SlaveEscape][Teleport] when=... before=... after=... success=...` - teleport 过程日志
- `[SlaveEscape][Teleport] 城市列表` - 用于验证 Y 轴方向

## 当前代码状态

- ✅ 代码已编译通过（0 errors, 0 warnings）
- ✅ CampaignBehavior 已正确注册
- ✅ **OnCharacterCreationFinalized Postfix 已实现**（核心修复）
- ✅ **SetSlaveEscapeStartingLocation 返回 bool**（只有成功才清空 Pending）
- ✅ **移除了 TeleportPartyAction 猜测**（直接使用 Position2D）
- ✅ **添加了城市坐标打印**（验证 Y 轴方向）
- ✅ **增强了可判定日志**
- ⏳ **需要运行时验证** - 运行游戏测试，查看日志确认修复是否生效

## 调试检查清单

运行游戏后，请检查以下日志：

1. **Node 选择时**:
   - `[OS] [SlaveEscape][Node5] 已保存期望出生位置: direction=desert`

2. **游戏开始时**:
   - `[OriginSystem] CampaignBehavior 已添加`
   - `[OriginSystem] 已应用预设出身: slave_escape`
   - `[OriginSystem] OnSessionLaunched: PendingStartDirection=desert`（需要添加此日志）

3. **延迟执行时**:
   - `[OS] [SlaveEscape][Teleport] 开始延迟执行: direction=desert settlementId=null`
   - `[OS] [SlaveEscape][Teleport] 找到目标定居点: ...`
   - `[OS] [SlaveEscape][Teleport] when=延迟执行 before=(...) targetSettlement=...`
   - `[OS] [SlaveEscape][Teleport] after=(...) success=True/False`

4. **验证时**:
   - `[OS] [SlaveEscape][VerifyNextTick] pos=(...)`

如果某个日志缺失，说明问题出在该步骤。

