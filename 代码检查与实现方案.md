# 代码检查与实现方案

## 一、反编译代码分析结果

### 1. NarrativeMenu 结构
```csharp
public sealed class NarrativeMenu
{
    public readonly string StringId;
    public readonly string InputMenuId;  // 关键：用于菜单链
    public readonly string OutputMenuId;
    public readonly TextObject Title;
    public readonly TextObject Description;
    public MBReadOnlyList<NarrativeMenuOption> CharacterCreationMenuOptions;
    
    // 构造函数
    public NarrativeMenu(
        string stringId, 
        string inputMenuId,      // 前一个菜单的 StringId，如果是第一个菜单则用 "start"
        string outputMenuId,     // 下一个菜单的 StringId
        TextObject title, 
        TextObject description, 
        List<NarrativeMenuCharacter> characters, 
        GetNarrativeMenuCharacterArgsDelegate getNarrativeMenuCharacterArgs);
    
    public void AddNarrativeMenuOption(NarrativeMenuOption narrativeMenuOption);
}
```

### 2. NarrativeMenuOption 结构
```csharp
public sealed class NarrativeMenuOption
{
    public readonly string StringId;
    public readonly TextObject Text;
    public readonly TextObject DescriptionText;
    public readonly NarrativeMenuOptionArgs Args;
    
    // 构造函数
    public NarrativeMenuOption(
        string stringId, 
        TextObject text, 
        TextObject descriptionText, 
        GetNarrativeMenuOptionArgsDelegate getNarrativeMenuOptionArgs,  // 设置 Args
        NarrativeMenuOptionOnConditionDelegate onCondition,           // 条件检查
        NarrativeMenuOptionOnSelectDelegate onSelect,                  // 选择回调
        NarrativeMenuOptionOnConsequenceDelegate onConsequence);      // 后果回调（可选）
    
    public bool OnCondition(CharacterCreationManager characterCreationManager);
    public void OnSelect(CharacterCreationManager characterCreationManager);
    public void OnConsequence(CharacterCreationManager characterCreationManager);
}
```

### 3. CharacterCreationManager 关键方法
```csharp
public void AddNewMenu(NarrativeMenu menu);  // 添加新菜单
public void StartNarrativeStage();           // 启动叙事阶段，查找 InputMenuId == "start" 的菜单
public bool TrySwitchToNextMenu();           // 切换到下一个菜单（根据 OutputMenuId）
public void OnNarrativeMenuOptionSelected(NarrativeMenuOption option);  // 选择选项
public IEnumerable<NarrativeMenuOption> GetSuitableNarrativeMenuOptions();  // 获取可用选项
```

### 4. CharacterCreationCampaignBehavior 流程
```csharp
// 在 InitializeContent 中：
AddParentsMenu(characterCreationManager);  // 创建第一个菜单，InputMenuId = "start"
// 在 AddParentsMenu 中：
AddKhuzaitNarrativeMenuOptions(narrativeMenu);  // 添加库塞特出身选项
characterCreationManager.AddNewMenu(narrativeMenu);  // 添加到管理器
```

## 二、当前代码问题检查

### ✅ 已正确
1. **OriginSystemHelper.cs** - 数据结构正确
2. **OriginSystemSubModule.cs** - Harmony 初始化正确
3. **OriginSystemCampaignBehavior.cs** - 事件注册正确

### ❌ 需要修复
1. **OriginSystemPatches.cs** - 完全空，需要实现
2. **PresetOriginSystem.cs** - 只有框架，需要实现具体逻辑
3. **NonPresetOriginSystem.cs** - 只有框架，需要实现具体逻辑

## 三、实现方案

### 方案 A：通过 Harmony Patch 修改 AddParentsMenu（推荐）

**优点**：
- 不需要实现完整的 ICharacterCreationContentHandler
- 可以修改现有的菜单添加逻辑
- 可以插入自定义菜单作为第一个菜单

**实现步骤**：
1. Patch `CharacterCreationCampaignBehavior.AddParentsMenu()` 的 Postfix
2. 在 Postfix 中：
   - 创建一个新的"出身类型选择"菜单（InputMenuId = "start"）
   - 修改原"父母菜单"的 InputMenuId（从 "start" 改为 "origin_type_selection"）
   - 将新菜单插入到第一个位置

### 方案 B：实现 ICharacterCreationContentHandler（更复杂）

**优点**：
- 完全控制菜单创建流程
- 可以完全替换原菜单

**缺点**：
- 需要实现所有接口方法
- 需要复制大量原代码

## 四、推荐实现（方案 A）

### Step 1: 实现 Harmony Patch

```csharp
[HarmonyPatch(typeof(CharacterCreationCampaignBehavior), "AddParentsMenu")]
public static class OriginSystemPatches
{
    static void Postfix(CharacterCreationManager characterCreationManager)
    {
        // 1. 创建"出身类型选择"菜单
        var originTypeMenu = CreateOriginTypeSelectionMenu(characterCreationManager);
        
        // 2. 修改原"父母菜单"的 InputMenuId
        var parentMenu = characterCreationManager.GetNarrativeMenuWithId("narrative_parent_menu");
        if (parentMenu != null)
        {
            // 使用反射修改 InputMenuId（因为它是 readonly）
            // 或者：删除原菜单，重新创建
        }
        
        // 3. 将新菜单插入到第一个位置
        // 注意：需要确保 InputMenuId == "start" 的菜单是第一个
    }
}
```

### Step 2: 创建菜单的辅助方法

```csharp
private static NarrativeMenu CreateOriginTypeSelectionMenu(CharacterCreationManager manager)
{
    // 创建角色列表（可以为空或使用默认角色）
    var characters = new List<NarrativeMenuCharacter>();
    
    // 创建菜单
    var menu = new NarrativeMenu(
        "origin_type_selection",
        "start",  // 第一个菜单
        "narrative_parent_menu",  // 下一个菜单
        new TextObject("选择出身类型"),
        new TextObject("选择你的出身类型..."),
        characters,
        GetOriginTypeMenuCharacterArgs  // 委托方法
    );
    
    // 添加选项
    menu.AddNarrativeMenuOption(new NarrativeMenuOption(
        "preset_origin_option",
        new TextObject("预设出身"),
        new TextObject("选择一个预设的出身背景（带剧本、带势力）"),
        GetPresetOriginArgs,
        PresetOriginOnCondition,
        PresetOriginOnSelect,
        null
    ));
    
    menu.AddNarrativeMenuOption(new NarrativeMenuOption(
        "non_preset_origin_option",
        new TextObject("非预设出身"),
        new TextObject("自由拼装你的出身（高自由度）"),
        GetNonPresetOriginArgs,
        NonPresetOriginOnCondition,
        NonPresetOriginOnSelect,
        null
    ));
    
    return menu;
}
```

## 五、关键注意事项

1. **InputMenuId == "start"** 的菜单必须是第一个菜单，`StartNarrativeStage()` 会查找它
2. **菜单链**：通过 InputMenuId 和 OutputMenuId 连接
3. **NarrativeMenuCharacter**：菜单中的角色显示，可以为空列表
4. **GetNarrativeMenuCharacterArgsDelegate**：动态获取角色参数，必须提供

## 六、下一步行动

1. ✅ 实现 `OriginSystemPatches.cs` - Harmony Patch
2. ✅ 实现菜单创建辅助方法
3. ✅ 实现预设出身选择菜单
4. ✅ 实现非预设出身三步选择菜单
5. ✅ 测试菜单链是否正确连接











































