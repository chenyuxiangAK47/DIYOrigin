# 问题分析：选择预设和非预设都走预设流程

## 问题描述

在 `origin_type_selection` 菜单中：
- **选择"预设出身"** → 应该进入 `preset_origin_selection` 菜单 ✅
- **选择"非预设出身"** → 应该进入 `non_preset_culture_anchor` 菜单 ❌ **但实际也进入了预设出身的菜单**

## 代码分析

### 1. `CreateOriginTypeSelectionMenu` 的默认 OutputMenuId

```csharp
// OriginSystemPatches.cs 第 485-510 行
private static NarrativeMenu CreateOriginTypeSelectionMenu(CharacterCreationManager manager)
{
    var menu = new NarrativeMenu(
        "origin_type_selection",
        "start",  // InputMenuId
        "preset_origin_selection",  // ❌ 默认 OutputMenuId 写死为 "preset_origin_selection"
        ...
    );
    
    // 添加两个选项
    menu.AddNarrativeMenuOption(new NarrativeMenuOption(
        "preset_origin_option",
        ...
    ));
    
    menu.AddNarrativeMenuOption(new NarrativeMenuOption(
        "non_preset_origin_option",
        ...
    ));
}
```

**问题**：默认 `OutputMenuId` 被写死为 `"preset_origin_selection"`，如果 Prefix 没有正确修改，引擎会走默认路径。

### 2. Prefix 路由逻辑

```csharp
// OriginSystemPatches.cs 第 5519-5544 行
static void Prefix(CharacterCreationManager __instance, NarrativeMenuOption option)
{
    var currentMenuId = __instance.CurrentMenu.StringId;
    var optionId = option.StringId;
    
    string targetMenuId = null;
    
    if (currentMenuId == "origin_type_selection")
    {
        if (optionId == "preset_origin_option")
        {
            targetMenuId = "preset_origin_selection";
        }
        else if (optionId == "non_preset_origin_option")
        {
            targetMenuId = "non_preset_culture_anchor";
        }
    }
    
    if (string.IsNullOrEmpty(targetMenuId)) return;  // ❌ 如果 optionId 不匹配，直接返回，不修改 OutputMenuId
    
    // 修改 OutputMenuId
    outputMenuIdField.SetValue(__instance.CurrentMenu, targetMenuId);
}
```

### 3. 可能的问题原因

#### 问题 1：option.StringId 不匹配

**可能情况**：
- `option.StringId` 的实际值不是 `"preset_origin_option"` 或 `"non_preset_origin_option"`
- 可能是其他值，导致 Prefix 的 `if` 条件都不满足
- 结果：`targetMenuId` 为空，直接 `return`，不修改 `OutputMenuId`
- 引擎使用默认的 `OutputMenuId = "preset_origin_selection"`，所以都走预设流程

#### 问题 2：Prefix 没有被调用

**可能情况**：
- Harmony Patch 没有正确应用
- `OnNarrativeMenuOptionSelected` 方法签名不匹配
- 结果：Prefix 不执行，`OutputMenuId` 保持默认值

#### 问题 3：菜单查找失败

**可能情况**：
- `GetNarrativeMenuWithId("non_preset_culture_anchor")` 返回 `null`
- Prefix 提前返回，不修改 `OutputMenuId`
- 结果：引擎使用默认的 `OutputMenuId`

## 需要确认的信息

### 1. 选项的实际 StringId

**问题**：`option.StringId` 的实际值是什么？

**检查方法**：
- 在 Prefix 中添加日志：`Debug.Print($"[OriginSystem] Prefix: option.StringId = {optionId}");`
- 运行游戏，选择"非预设出身"，查看日志输出

**可能的值**：
- `"non_preset_origin_option"` ✅ 正确
- `"non_preset_origin"` ❌ 不匹配
- `"non_preset"` ❌ 不匹配
- 其他值 ❌ 不匹配

### 2. Prefix 是否被调用

**检查方法**：
- 在 Prefix 开头添加日志：`Debug.Print("[OriginSystem] Prefix: OnNarrativeMenuOptionSelected 被调用");`
- 运行游戏，选择任意选项，查看是否有日志输出

**如果没有日志**：
- Harmony Patch 可能没有正确应用
- 检查 `[HarmonyPatch]` 属性是否正确
- 检查方法签名是否匹配

### 3. 菜单是否存在

**检查方法**：
- 在 Prefix 中添加日志：`Debug.Print($"[OriginSystem] Prefix: 查找菜单 non_preset_culture_anchor, 结果 = {targetMenu != null}");`
- 运行游戏，选择"非预设出身"，查看日志输出

**如果返回 null**：
- `non_preset_culture_anchor` 菜单可能没有正确注册
- 检查 `CreateNonPresetCultureAnchorMenu` 是否被调用
- 检查菜单的 `StringId` 是否正确

### 4. OutputMenuId 是否被修改

**检查方法**：
- 在 Prefix 中添加日志：`Debug.Print($"[OriginSystem] Prefix: 修改前 OutputMenuId = {originalOutputMenuId}, 修改后 = {targetMenuId}");`
- 在 Postfix 中添加日志：`Debug.Print($"[OriginSystem] Postfix: 当前 OutputMenuId = {__instance.CurrentMenu.OutputMenuId}");`
- 运行游戏，选择"非预设出身"，查看日志输出

**如果修改后还是 `"preset_origin_selection"`**：
- 反射修改可能失败
- 或者引擎在 Prefix 之后又重置了 `OutputMenuId`

## 建议的调试步骤

### 步骤 1：添加详细日志

在 Prefix 中添加以下日志：

```csharp
static void Prefix(CharacterCreationManager __instance, NarrativeMenuOption option)
{
    Debug.Print("[OriginSystem] ========== Prefix 开始 ==========", 0, Debug.DebugColor.Cyan);
    Debug.Print($"[OriginSystem] Prefix: CurrentMenu.StringId = {__instance.CurrentMenu?.StringId}", 0, Debug.DebugColor.Cyan);
    Debug.Print($"[OriginSystem] Prefix: option.StringId = {option?.StringId}", 0, Debug.DebugColor.Cyan);
    Debug.Print($"[OriginSystem] Prefix: option.Text = {option?.Text}", 0, Debug.DebugColor.Cyan);
    
    if (_isSwitching) 
    {
        Debug.Print("[OriginSystem] Prefix: _isSwitching = true, 跳过", 0, Debug.DebugColor.Yellow);
        return;
    }
    
    if (__instance.CurrentMenu == null || option == null) 
    {
        Debug.Print("[OriginSystem] Prefix: CurrentMenu 或 option 为 null, 跳过", 0, Debug.DebugColor.Yellow);
        return;
    }

    try
    {
        var currentMenuId = __instance.CurrentMenu.StringId;
        var optionId = option.StringId;
        
        Debug.Print($"[OriginSystem] Prefix: 当前菜单 = {currentMenuId}, 选项 = {optionId}", 0, Debug.DebugColor.Green);
        
        string targetMenuId = null;
        
        if (currentMenuId == "origin_type_selection")
        {
            Debug.Print("[OriginSystem] Prefix: 进入 origin_type_selection 路由逻辑", 0, Debug.DebugColor.Green);
            
            if (optionId == "preset_origin_option")
            {
                targetMenuId = "preset_origin_selection";
                Debug.Print($"[OriginSystem] Prefix: 匹配 preset_origin_option -> {targetMenuId}", 0, Debug.DebugColor.Green);
            }
            else if (optionId == "non_preset_origin_option")
            {
                targetMenuId = "non_preset_culture_anchor";
                Debug.Print($"[OriginSystem] Prefix: 匹配 non_preset_origin_option -> {targetMenuId}", 0, Debug.DebugColor.Green);
            }
            else
            {
                Debug.Print($"[OriginSystem] Prefix: 警告 - optionId 不匹配: {optionId}", 0, Debug.DebugColor.Red);
            }
        }
        else
        {
            Debug.Print($"[OriginSystem] Prefix: 当前菜单不是 origin_type_selection, 跳过路由", 0, Debug.DebugColor.Yellow);
        }
        
        if (string.IsNullOrEmpty(targetMenuId))
        {
            Debug.Print("[OriginSystem] Prefix: targetMenuId 为空, 不修改 OutputMenuId", 0, Debug.DebugColor.Yellow);
            return;
        }
        
        var targetMenu = __instance.GetNarrativeMenuWithId(targetMenuId);
        if (targetMenu == null)
        {
            Debug.Print($"[OriginSystem] Prefix: 警告 - 找不到目标菜单: {targetMenuId}", 0, Debug.DebugColor.Red);
            return;
        }
        
        Debug.Print($"[OriginSystem] Prefix: 找到目标菜单: {targetMenu.StringId}", 0, Debug.DebugColor.Green);
        
        var outputMenuIdField = typeof(NarrativeMenu).GetField("OutputMenuId",
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
        
        if (outputMenuIdField != null)
        {
            var originalOutputMenuId = __instance.CurrentMenu.OutputMenuId;
            
            outputMenuIdField.SetValue(__instance.CurrentMenu, targetMenuId);
            
            Debug.Print($"[OriginSystem] Prefix: 修改 OutputMenuId: {originalOutputMenuId} -> {targetMenuId}", 0, Debug.DebugColor.Green);
        }
        else
        {
            Debug.Print("[OriginSystem] Prefix: 警告 - 找不到 OutputMenuId 字段", 0, Debug.DebugColor.Red);
        }
        
        Debug.Print("[OriginSystem] ========== Prefix 结束 ==========", 0, Debug.DebugColor.Cyan);
    }
    catch (Exception ex)
    {
        Debug.Print("[OriginSystem] Prefix 失败: " + ex.Message, 0, Debug.DebugColor.Red);
        Debug.Print("[OriginSystem] StackTrace: " + ex.StackTrace, 0, Debug.DebugColor.Red);
    }
}
```

### 步骤 2：运行游戏并查看日志

1. 编译并运行游戏
2. 进入角色创建
3. 选择"预设出身"，查看日志
4. 选择"非预设出身"，查看日志
5. 对比两次日志的差异

### 步骤 3：根据日志结果修复

**如果 option.StringId 不匹配**：
- 修改 Prefix 中的条件判断，使用实际的 `optionId` 值

**如果 Prefix 没有被调用**：
- 检查 Harmony Patch 是否正确应用
- 检查方法签名是否匹配

**如果菜单查找失败**：
- 检查 `non_preset_culture_anchor` 菜单是否正确注册
- 检查菜单的 `StringId` 是否正确

**如果 OutputMenuId 修改失败**：
- 检查反射代码是否正确
- 检查字段名是否正确

## 代码位置

- **CreateOriginTypeSelectionMenu**：`OriginSystemPatches.cs` 第 485-510 行
- **Prefix 路由逻辑**：`OriginSystemPatches.cs` 第 5507-5562 行
- **CreateNonPresetCultureAnchorMenu**：`OriginSystemPatches.cs` 第 4109 行附近

## 编译错误

当前代码有大量编译错误（主要是语法错误），需要先修复编译错误才能测试。主要错误类型：
- `CS1513: 应输入 }` - 缺少右大括号
- `CS1002: 应输入 ;` - 缺少分号
- `CS1010: 常量中有换行符` - 字符串常量中有未转义的换行符
- `CS1519: Invalid token` - 无效的标记

这些错误可能是由之前的编码问题或字符串处理问题引起的。
























































